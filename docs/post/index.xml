<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on alexandru topliceanu</title>
    <link>http://alexandrutopliceanu.ro/post/</link>
    <description>Recent content in Posts on alexandru topliceanu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Mar 2018 19:25:53 +0000</lastBuildDate>
    
	<atom:link href="http://alexandrutopliceanu.ro/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Targeted Quantiles in Prometheus</title>
      <link>http://alexandrutopliceanu.ro/post/targeted-quantiles/</link>
      <pubDate>Sun, 11 Mar 2018 19:25:53 +0000</pubDate>
      
      <guid>http://alexandrutopliceanu.ro/post/targeted-quantiles/</guid>
      <description>The algorithm behind Prometheus&amp;rsquo; Summaries.
Abstract TODO
Introduction The hearthstone of understanding of how your distributed system works in production is monitoring. In recent years, Prometheus has emerged as the most popular monitoring system for applications deployed on Kubernetes. Apart from the more common counters and gauges, the prometheus client exposes the summary metric type. In a go project, it might look like this:
// This is the definition of a metric which tracks the latency of an RPC request.</description>
    </item>
    
    <item>
      <title>Scheduling in Kubernetes</title>
      <link>http://alexandrutopliceanu.ro/post/scheduling-in-kubernetes/</link>
      <pubDate>Thu, 01 Feb 2018 22:08:22 +0000</pubDate>
      
      <guid>http://alexandrutopliceanu.ro/post/scheduling-in-kubernetes/</guid>
      <description>The importance of understanding the implementation of the tools we use in production every day cannot be underestimated.
This process informs about the trade-offs engineers made in the implementations. Knowing a tool&amp;rsquo;s strengths and weaknesses helps better design systems on top of it; it exposes potential failure modes and helps debug critical errors when they occur. It also reveals brilliant ideas, tricks, patterns and conventions used in production systems.</description>
    </item>
    
    <item>
      <title>[video] Introduction to GraphQL</title>
      <link>http://alexandrutopliceanu.ro/post/introduction-to-graphql/</link>
      <pubDate>Fri, 17 Feb 2017 23:17:08 +0000</pubDate>
      
      <guid>http://alexandrutopliceanu.ro/post/introduction-to-graphql/</guid>
      <description>Introduction to GraphQL This post embeds a recorded presentation I gave at the offices of Pusher where I currently work.
The talk is a short introduction on GraphQL. My goal here is to describe how GraphQL works, how it positions against similar approaches and to give an example of how one might use it to design an API for a blog engine. If you want more details about that process I previously wrote a blog post GraphQL with Go and PostgreSQL and an implementation at github.</description>
    </item>
    
    <item>
      <title>Writing Quality Golang Code</title>
      <link>http://alexandrutopliceanu.ro/post/quality-go-code/</link>
      <pubDate>Sat, 11 Feb 2017 15:16:45 +0000</pubDate>
      
      <guid>http://alexandrutopliceanu.ro/post/quality-go-code/</guid>
      <description>The tools I use to help produce quality Golang code
Abstract Go has excellent libraries for source-code parsing. These have enabled the creators of Go and the open source community to produce a variety of tools which help eliminate errors in advance.
The large number of tools and the lack of documentation on how to best use them presents a problem for engineers. This blog post describes the process and the tools I use to improve code quality and catch bugs early in my Go code.</description>
    </item>
    
    <item>
      <title>GraphQL With Golang and PostgreSQL</title>
      <link>http://alexandrutopliceanu.ro/post/graphql-with-go-and-postgresql/</link>
      <pubDate>Sun, 22 Jan 2017 08:28:53 +0000</pubDate>
      
      <guid>http://alexandrutopliceanu.ro/post/graphql-with-go-and-postgresql/</guid>
      <description>Building a Blogging Engine API with Golang and PostgreSQL
Abstract GraphQL appears hard to use in production: the graph interface is flexible in its modeling capabilities but is a poor match for relational storage, both in terms of implementation and performance.
In this document, we will design and write a simple blogging engine API, with the following specification:
 three types of resources (users, posts and comments) supporting a varied set of functionality (create a user, create a post, add a comment to a post, follow posts and comments from another user, etc.</description>
    </item>
    
  </channel>
</rss>